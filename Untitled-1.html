<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris-like — Simple</title>
  <style>
    :root{--bg:#111;--panel:#1c1c1c;--accent:#4ee;--muted:#aaa}
    *{box-sizing:border-box;font-family:system-ui,Segoe UI,Roboto,Arial}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b1220,#071018);color:#e6eef6}
    .wrap{display:flex;gap:20px;align-items:flex-start;padding:28px}
    canvas{background:var(--panel);border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,.6)}
    .side{max-width:260px}
    h1{font-size:20px;margin:0 0 8px}
    .meta{color:var(--muted);font-size:13px;margin-bottom:12px}
    .big{font-size:28px;margin:6px 0}
    button{background:var(--accent);border:none;color:#013;padding:8px 12px;border-radius:6px;cursor:pointer;font-weight:600}
    .kbd{background:#111;padding:6px 8px;border-radius:6px;display:inline-block;margin:4px 4px 0}
    .muted{color:var(--muted);font-size:13px}
  </style>
</head>
<body>
  <div class="wrap">
    <div>
      <canvas id="board" width="240" height="480"></canvas>
    </div>
    <div class="side">
      <h1>Simple Tetris-like</h1>
      <div class="meta">Play a compact Tetris clone — open locally in your browser.</div>
      <div>Score: <span id="score" class="big">0</span></div>
      <div>Level: <span id="level" class="big">1</span></div>
      <div class="muted" style="margin-top:12px">Next:</div>
      <canvas id="next" width="120" height="120" style="background:transparent;margin-top:8px;display:block;border-radius:6px"></canvas>
      <div style="margin-top:12px" class="muted">Controls</div>
      <div><span class="kbd">←</span><span class="kbd">→</span> Move</div>
      <div><span class="kbd">Z / ↑</span> Rotate</div>
      <div><span class="kbd">Space</span> Hard drop</div>
      <div><span class="kbd">↓</span> Soft drop</div>
      <div style="margin-top:12px"><button id="start">Start / Restart</button></div>
      <p class="muted" style="margin-top:18px;font-size:13px">Want this in Roblox (Lua) or Unity (C#)? Ask and I'll convert it for you.</p>
    </div>
  </div>

<script>
// ---- Simple Tetris-like implementation ----
const COLS = 10, ROWS = 20, BLOCK = 24;
const cvs = document.getElementById('board');
const ctx = cvs.getContext('2d');
const nextCvs = document.getElementById('next');
const nctx = nextCvs.getContext('2d');
let scoreEl = document.getElementById('score'), levelEl = document.getElementById('level');

// Colors for pieces
const COLORS = {
  I: '#4ee', J: '#66c', L: '#f6a', O: '#ffb86b', S: '#6f6', T: '#b58fff', Z: '#f66'
};

// Tetromino shapes (rotation states)
const SHAPES = {
  I: [[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]]],
  J: [[[1,0,0],[1,1,1],[0,0,0]], [[0,1,1],[0,1,0],[0,1,0]], [[0,0,0],[1,1,1],[0,0,1]], [[0,1,0],[0,1,0],[1,1,0]]],
  L: [[[0,0,1],[1,1,1],[0,0,0]], [[0,1,0],[0,1,0],[0,1,1]], [[0,0,0],[1,1,1],[1,0,0]], [[1,1,0],[0,1,0],[0,1,0]]],
  O: [[[1,1],[1,1]]],
  S: [[[0,1,1],[1,1,0],[0,0,0]], [[0,1,0],[0,1,1],[0,0,1]]],
  T: [[[0,1,0],[1,1,1],[0,0,0]], [[0,1,0],[0,1,1],[0,1,0]], [[0,0,0],[1,1,1],[0,1,0]], [[0,1,0],[1,1,0],[0,1,0]]],
  Z: [[[1,1,0],[0,1,1],[0,0,0]], [[0,0,1],[0,1,1],[0,1,0]]]
};

// Utility
function randChoice(arr){return arr[Math.floor(Math.random()*arr.length)];}

// Board init
let board = createEmpty();
function createEmpty(){
  return Array.from({length:ROWS},()=>Array(COLS).fill(''));
}

// Piece factory (with rotation states)
function makePiece(type){
  const rots = SHAPES[type].map(s=>s.map(r=>r.slice()));
  return {type, rots, rot:0, x: Math.floor((COLS - rots[0][0].length)/2), y: - (rots[0].length)};
}

let current = null, next = null;
let dropInterval = 800, dropTimer = 0, lastTime = 0;
let score = 0, level = 1, lines = 0, gameOver = false;
let playing = false;

function resetGame(){
  board = createEmpty();
  score = 0; lines = 0; level = 1; dropInterval = 800; gameOver=false; playing=true;
  current = makePiece(randChoice(Object.keys(SHAPES)));
  next = makePiece(randChoice(Object.keys(SHAPES)));
  updateHUD();
}

// Draw helpers
function drawCell(ctx,x,y,color){
  ctx.fillStyle = color || '#222';
  ctx.fillRect(x*BLOCK + 1, y*BLOCK + 1, BLOCK-2, BLOCK-2);
}

function draw(){
  ctx.clearRect(0,0,cvs.width,cvs.height);
  // draw board
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const v = board[r][c];
      drawCell(ctx,c,r, v ? COLORS[v] : '#111');
    }
  }
  // draw current piece
  if(current) {
    const shape = current.rots[current.rot];
    for(let r=0;r<shape.length;r++) for(let c=0;c<shape[r].length;c++) if(shape[r][c]){
      const X = current.x + c, Y = current.y + r;
      if(Y>=0) drawCell(ctx,X,Y, COLORS[current.type]);
    }
  }
}

function drawNext(){
  nctx.clearRect(0,0,nextCvs.width,nextCvs.height);
  if(!next) return;
  const s = next.rots[next.rot];
  const cell = 24;
  const offsetX = Math.floor((nextCvs.width/ cell - s[0].length)/2);
  const offsetY = Math.floor((nextCvs.height/ cell - s.length)/2);
  for(let r=0;r<s.length;r++) for(let c=0;c<s[r].length;c++) if(s[r][c]){
    nctx.fillStyle = COLORS[next.type];
    nctx.fillRect((c+offsetX)*cell+6,(r+offsetY)*cell+6,cell-12,cell-12);
  }
}

// Collision check
function collides(piece, x=piece.x, y=piece.y, rot=piece.rot){
  const shape = piece.rots[rot];
  for(let r=0;r<shape.length;r++) for(let c=0;c<shape[r].length;c++) if(shape[r][c]){
    const X = x+c, Y = y+r;
    if(X<0 || X>=COLS || Y>=ROWS) return true;
    if(Y>=0 && board[Y][X]) return true;
  }
  return false;
}

// Lock piece to board
function lockPiece(){
  const shape = current.rots[current.rot];
  for(let r=0;r<shape.length;r++) for(let c=0;c<shape[r].length;c++) if(shape[r][c]){
    const X = current.x + c, Y = current.y + r;
    if(Y<0){ gameOver = true; playing=false; return; }
    board[Y][X] = current.type;
  }
  clearLines();
  spawnFromNext();
}

function spawnFromNext(){
  current = next; next = makePiece(randChoice(Object.keys(SHAPES)));
  current.x = Math.floor((COLS - current.rots[0][0].length)/2);
  current.y = - current.rots[0].length;
  if(collides(current)) { gameOver=true; playing=false; }
}

// Clear lines
function clearLines(){
  let cleared = 0;
  for(let r=ROWS-1;r>=0;r--){
    if(board[r].every(c=>c)){
      board.splice(r,1); board.unshift(Array(COLS).fill(''));
      cleared++; r++; // re-check same row index after shift
    }
  }
  if(cleared>0){
    lines += cleared;
    score += [0,40,100,300,1200][cleared] * level; // classic scoring
    level = Math.floor(lines/10) + 1;
    dropInterval = Math.max(80, 800 - (level-1)*60);
    updateHUD();
  }
}

function updateHUD(){ scoreEl.textContent = score; levelEl.textContent = level; drawNext(); }

// Move / rotate
function move(dx){ if(!current) return; const nx = current.x + dx; if(!collides(current,nx,current.y,current.rot)){ current.x = nx; draw(); }}
function softDrop(){ if(!current) return; current.y++; if(collides(current,current.x,current.y,current.rot)){ current.y--; lockPiece(); } draw(); }
function hardDrop(){ if(!current) return; while(!collides(current,current.x,current.y+1,current.rot)) current.y++; lockPiece(); draw(); }
function rotate(dir=1){ if(!current) return; const newRot = (current.rot + dir + current.rots.length) % current.rots.length;
  // basic wall kick: try offsets
  const kicks = [0, -1, 1, -2, 2];
  for(let k of kicks){ if(!collides(current,current.x+k,current.y,newRot)){ current.rot=newRot; current.x+=k; draw(); break; }}
}

// Input
document.addEventListener('keydown', e=>{
  if(!playing && e.key === ' '){ resetGame(); return; }
  if(!playing) return;
  if(e.key === 'ArrowLeft') move(-1);
  else if(e.key === 'ArrowRight') move(1);
  else if(e.key === 'ArrowDown') { softDrop(); }
  else if(e.key === ' '){ e.preventDefault(); hardDrop(); }
  else if(e.key === 'z' || e.key === 'Z' || e.key === 'ArrowUp') rotate(1);
});

// Game loop
function update(time=0){
  if(!lastTime) lastTime=time;
  const delta = time - lastTime; lastTime = time;
  if(playing && !gameOver){
    dropTimer += delta;
    if(dropTimer > dropInterval){
      dropTimer = 0;
      if(!current) spawnFromNext();
      current.y++;
      if(collides(current,current.x,current.y,current.rot)){
        current.y--; lockPiece();
      }
    }
  }
  draw();
  requestAnimationFrame(update);
}
requestAnimationFrame(update);

// Start/Restart button
document.getElementById('start').addEventListener('click', ()=>{ resetGame(); draw(); });

// start paused; show initial next piece
next = makePiece(randChoice(Object.keys(SHAPES)));
draw(); drawNext();

</script>
</body>
</html>
